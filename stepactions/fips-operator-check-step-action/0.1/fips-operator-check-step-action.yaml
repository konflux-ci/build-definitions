---
apiVersion: tekton.dev/v1beta1
kind: StepAction
metadata:
  labels:
    app.kubernetes.io/version: "0.1"
  annotations:
    tekton.dev/pipelines.minVersion: "0.12.1"
    tekton.dev/tags: "konflux"
  name: fips-operator-check-step-action
spec:
  description: >-
    This stepAction scans relatedImages of operator bundle image builds for FIPS compliance using the check-payload tool.
  results:
    - name: TEST_OUTPUT
      description: Tekton task test output.
  image: quay.io/konflux-ci/konflux-test:v1.4.34@sha256:62a7bf68015c711e0eb0698c10d203d0393a8e0efa09306f1fce543dea383f3c
  securityContext:
    capabilities:
      add:
        - SETFCAP
  script: |
    #!/usr/bin/env bash
    set -euo pipefail
    # shellcheck source=/dev/null
    . /utils.sh

    # Create temporary files for thread-safe counters
    success_counter_file=$(mktemp)
    warnings_counter_file=$(mktemp)
    error_counter_file=$(mktemp)
    failure_counter_file=$(mktemp)
    echo "0" > "$success_counter_file"
    echo "0" > "$warnings_counter_file"
    echo "0" > "$error_counter_file"
    echo "0" > "$failure_counter_file"

    export RETRY_COUNT=2
    export RETRY_INTERVAL=5

    # Set default parallel jobs if not provided
    PARALLEL_JOBS=${PARALLEL_JOBS:-5}

    if [ ! -e "/tekton/home/unique_related_images.txt" ]; then
      echo "No relatedImages to process"
      exit 0
    fi

    mapfile -d ' ' -t related_images < <(cat /tekton/home/unique_related_images.txt)
    echo "Related images are :"
    printf "%s\n" "${related_images[@]}"

    # If target OCP version is found, use it to apply the exception list when running check-payload
    check_payload_version=""
    if [ -f "/tekton/home/target_ocp_version.txt" ]; then
      version=$(cat "/tekton/home/target_ocp_version.txt")
      check_payload_version="-V=${version}"
      echo "Target OCP version found: ${check_payload_version}"
    fi

    # Check if an image to mirror map is defined for unreleased images
    image_mirror_map=""
    if [ -f "/tekton/home/related-images-map.txt" ]; then
      image_mirror_map=$(cat "/tekton/home/related-images-map.txt")
      echo "Image Mirror Map found:"
      echo "${image_mirror_map}" | jq '.'
    fi

    # Function to increment counter atomically
    increment_counter() {
      local counter_file="$1"
      local lockfile="${counter_file}.lock"
      (
        flock -x 9
        local current
        current=$(cat "$counter_file")
        echo $((current + 1)) > "$counter_file"
      ) 9>"$lockfile"
    }

    # Function to process a single image
    process_image() {
      local related_image="$1"
      local count="$2"
      related_image="${related_image//$'\n'/}"
      echo "Processing related image ${count} of ${#related_images[@]}: ${related_image}"

      image_accessible=0
      if ! image_labels=$(get_image_labels "$related_image"); then
        echo "Could not inspect original pullspec $related_image. Checking if there's a mirror present"
        if [ -n "${image_mirror_map}" ]; then
          reg_and_repo=$(get_image_registry_and_repository "${related_image}")
          mapfile -t mirrors < <(echo "${image_mirror_map}" | jq -r --arg image "${reg_and_repo}" '.[$image][]')
          echo "Mirrors for $reg_and_repo are:"
          printf "%s\n" "${mirrors[@]}"

          for mirror in "${mirrors[@]}"; do
            echo "Attempting to use mirror ${mirror}"
            replaced_image=$(replace_image_pullspec "$related_image" "$mirror")
            if ! image_labels=$(get_image_labels "$replaced_image"); then
              echo "Mirror $mirror is inaccessible."
              continue
            fi
            image_accessible=1
            echo "Replacing $related_image with $replaced_image"
            related_image="$replaced_image"
            break
          done

        fi
      else
        image_accessible=1
        echo "Successfully inspected $related_image. Mirror not required."
      fi

      if [[ $image_accessible -eq 0 ]]; then
        echo -e "Error: Unable to scan image: Could not inspect image ${related_image} for labels\n"
        increment_counter "$error_counter_file"
        return
      fi
      component_label=$(echo "${image_labels}" | grep 'com.redhat.component=' | cut -d= -f2 | tr -d '\n\r' | xargs || true)
      version_label=$(echo "${image_labels}" | grep '^version=' | cut -d= -f2 | tr -d '\n\r' | xargs || true)
      release_label=$(echo "${image_labels}" | grep 'release=' | cut -d= -f2 | tr -d '\n\r' | xargs || true)
      echo "Component label is ${component_label}"
      echo "Version label is ${version_label}"
      echo "Release label is ${release_label}"

      if [ -z "${component_label}" ]; then
        echo -e "Error: Unable to scan image: Could not get com.redhat.component label for ${related_image}\n"
        increment_counter "$error_counter_file"
        return
      fi

      # Convert image to OCI format since umoci can only handle the OCI format
      if ! retry skopeo copy --remove-signatures "docker://${related_image}" "oci:///tekton/home/${component_label}-${version_label}-${release_label}:latest"; then
        echo -e "Error: Unable to scan image: Could not convert image ${related_image} to OCI format\n"
        increment_counter "$error_counter_file"
        return
      fi

      # Unpack OCI image
      if ! retry umoci raw unpack --rootless \
          --image "/tekton/home/${component_label}-${version_label}-${release_label}:latest" \
          "/tekton/home/unpacked-${component_label}-${version_label}-${release_label}"; then
        echo -e "Error: Unable to scan image: Could not unpack OCI image ${related_image}\n"
        increment_counter "$error_counter_file"
        return
      fi

      # Run check-payload on the unpacked image
      # The check-payload command fails with exit 1 when the scan for an image is unsuccessful
      # or when the image is not FIPS compliant. Hence, count those as failures and not errors
      if ! check-payload scan local \
          --path="/tekton/home/unpacked-${component_label}-${version_label}-${release_label}" \
          "${check_payload_version}" \
          --components="${component_label}" \
          --output-format=csv \
          --output-file="/tekton/home/report-${component_label}-${version_label}-${release_label}.csv"; then
        echo -e "check-payload scan failed for ${related_image}\n"
        increment_counter "$failure_counter_file"
        return
      fi

      if [ -f "/tekton/home/report-${component_label}-${version_label}-${release_label}.csv" ]; then
        if grep -q -- "---- Successful run" "/tekton/home/report-${component_label}-${version_label}-${release_label}.csv"; then
          echo -e "check-payload scan was successful for ${related_image}\n"
          increment_counter "$success_counter_file"
        elif grep -q -- "---- Successful run with warnings" "/tekton/home/report-${component_label}-${version_label}-${release_label}.csv"; then
          echo -e "check-payload scan was successful with warnings for ${related_image}\n"
          increment_counter "$warnings_counter_file"
        fi
      fi
    }

    # Process images in parallel
    declare -i count=0
    for related_image in "${related_images[@]}"; do
      count+=1

      # Wait for available slot if we've reached max parallel jobs
      while [ "$(jobs -r | wc -l)" -ge "${PARALLEL_JOBS}" ]; do
        sleep 1
      done

      # Start processing image in background
      process_image "$related_image" "$count" &
    done

    # Wait for all background jobs to complete
    wait

    # Read final counter values
    success_counter=$(cat "$success_counter_file")
    warnings_counter=$(cat "$warnings_counter_file")
    error_counter=$(cat "$error_counter_file")
    failure_counter=$(cat "$failure_counter_file")

    # Clean up temporary files
    rm -f "$success_counter_file" "$warnings_counter_file" "$error_counter_file" "$failure_counter_file"

    note="Task $(context.task.name) failed: Some images could not be scanned. For details, check Tekton task log."
    ERROR_OUTPUT=$(make_result_json -r ERROR -t "$note")

    note="Task $(context.task.name) completed: Check result for task result."
    if [[ "$error_counter" == 0 ]];
    then
      if [[ "${failure_counter}" -gt 0 ]]; then
        RES="FAILURE"
      elif [[ "${warnings_counter}" -gt 0 ]]; then
        RES="WARNING"
      else
        RES="SUCCESS"
      fi
      TEST_OUTPUT=$(make_result_json \
        -r "${RES}" \
        -s "${success_counter}" -f "${failure_counter}" -w "${warnings_counter}" -t "$note")
    fi
    echo "${TEST_OUTPUT:-${ERROR_OUTPUT}}" | tee "$(step.results.TEST_OUTPUT.path)"

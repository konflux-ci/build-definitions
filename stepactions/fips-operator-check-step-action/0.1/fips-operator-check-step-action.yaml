---
apiVersion: tekton.dev/v1beta1
kind: StepAction
metadata:
  labels:
    app.kubernetes.io/version: "0.1"
  annotations:
    tekton.dev/pipelines.minVersion: "0.12.1"
    tekton.dev/tags: "konflux"
  name: fips-operator-check-step-action
spec:
  description: >-
    This stepAction scans relatedImages of operator bundle image builds for FIPS compliance using the check-payload tool.
  params:
    - name: MAX_PARALLEL
      description: Maximum number of images to process in parallel (default 8)
      default: "8"
  env:
    - name: MAX_PARALLEL
      value: $(params.MAX_PARALLEL)
  results:
    - name: TEST_OUTPUT
      description: Tekton task test output.
  image: quay.io/konflux-ci/konflux-test:v1.4.41@sha256:afea44d83043be7f528ec2cacaeb0c3b69cdafdd86a1b930957def38400f8a6c
  securityContext:
    capabilities:
      add:
        - SETFCAP
  script: |
    #!/usr/bin/env bash
    set -euo pipefail
    # shellcheck source=/dev/null
    . /utils.sh

    export RETRY_COUNT=2
    export RETRY_INTERVAL=5

    # Create temporary directory for parallel processing counters
    counter_dir=$(mktemp -d)
    trap 'rm -rf "$counter_dir"' EXIT

    # Function to clean up OCI image and unpacked directory
    cleanup_image_artifacts() {
      local image_num="$1"
      local component_label="$2"
      local version_label="$3"
      local release_label="$4"
      # Clean up OCI image (may or may not exist depending on failure point)
      rm -rf "/tekton/home/${image_num}-${component_label}-${version_label}-${release_label}:latest" 2>/dev/null || true
      # Clean up unpacked directory (may or may not exist depending on failure point)
      rm -rf "/tekton/home/unpacked-${image_num}-${component_label}-${version_label}-${release_label}" 2>/dev/null || true
    }

    # Function to process a single related image
    process_image() {
      # shellcheck source=/dev/null
      . /utils.sh

      local related_image="$1"
      local image_num="$2"
      local total_images="$3"
      local check_payload_version="$4"
      local image_mirror_map="$5"

      related_image="${related_image//$'\n'/}"
      echo "Processing related image ${image_num} of ${total_images}: ${related_image}"

      image_accessible=0
      if ! image_labels=$(get_image_labels "$related_image"); then
        echo "Could not inspect original pullspec $related_image. Checking if there's a mirror present"
        if [ -n "${image_mirror_map}" ]; then
          reg_and_repo=$(get_image_registry_and_repository "${related_image}")
          mapfile -t mirrors < <(get_image_mirror_list "${reg_and_repo}" "${image_mirror_map}")
          if [[ -z "${mirrors[0]}" ]]; then
            echo "No mirrors found in image mirror map for ${reg_and_repo}"
          else
            echo "Mirrors for $reg_and_repo are:"
            printf "%s\n" "${mirrors[@]}"

            for mirror in "${mirrors[@]}"; do
              echo "Attempting to use mirror ${mirror}"
              replaced_image=$(replace_image_pullspec "$related_image" "$mirror")
              if ! image_labels=$(get_image_labels "$replaced_image"); then
                echo "Mirror $mirror is inaccessible."
                continue
              fi
              image_accessible=1
              echo "Replacing $related_image with $replaced_image"
              related_image="$replaced_image"
              break
            done
          fi
        fi
      else
        image_accessible=1
        echo "Successfully inspected $related_image. Mirror not required."
      fi

      if [[ $image_accessible -eq 0 ]]; then
        echo -e "Error: Unable to scan image: Could not inspect image ${related_image} for labels\n"
        echo "1" >> "${counter_dir}/error"
        return
      fi
      component_label=$(echo "${image_labels}" | grep 'com.redhat.component=' | cut -d= -f2 | tr -d '\n\r' | xargs || true)
      version_label=$(echo "${image_labels}" | grep '^version=' | cut -d= -f2 | tr -d '\n\r' | xargs || true)
      release_label=$(echo "${image_labels}" | grep 'release=' | cut -d= -f2 | tr -d '\n\r' | xargs || true)
      echo "Component label is ${component_label}"
      echo "Version label is ${version_label}"
      echo "Release label is ${release_label}"

      if [ -z "${component_label}" ]; then
        echo -e "Error: Unable to scan image: Could not get com.redhat.component label for ${related_image}\n"
        echo "1" >> "${counter_dir}/error"
        return
      fi

      # Sanitize the image reference to handle Docker references with both tag and digest
      sanitized_related_image=$(get_image_registry_repository_digest "${related_image}")

      # If no digest is present, fallback to using tag-based sanitization
      if [[ "${sanitized_related_image}" != *"@"* ]]; then
        echo "No digest found in sanitized image, using tag-based sanitization"
        sanitized_related_image=$(get_image_registry_repository_tag "${related_image}")
      fi
      echo "Successfully sanitized image reference: ${sanitized_related_image}. Using sanitized image reference for conversion to OCI format"

      # Convert image to OCI format since umoci can only handle the OCI format
      if ! retry skopeo copy --remove-signatures "docker://${sanitized_related_image}" "oci:///tekton/home/${image_num}-${component_label}-${version_label}-${release_label}:latest"; then
        echo -e "Error: Unable to scan image: Could not convert image ${related_image} to OCI format\n"
        # Clean up any partial OCI image artifacts to prevent resource accumulation
        cleanup_image_artifacts "${image_num}" "${component_label}" "${version_label}" "${release_label}"
        echo "1" >> "${counter_dir}/error"
        return
      fi

      # Unpack OCI image
      if ! retry umoci raw unpack --rootless \
          --image "/tekton/home/${image_num}-${component_label}-${version_label}-${release_label}:latest" \
          "/tekton/home/unpacked-${image_num}-${component_label}-${version_label}-${release_label}"; then
        echo -e "Error: Unable to scan image: Could not unpack OCI image ${related_image}\n"
        # Clean up OCI image and any partial unpacked directory to prevent resource accumulation
        cleanup_image_artifacts "${image_num}" "${component_label}" "${version_label}" "${release_label}"
        echo "1" >> "${counter_dir}/error"
        return
      fi

      # Run check-payload on the unpacked image
      # The check-payload command fails with exit 1 when the scan for an image is unsuccessful
      # or when the image is not FIPS compliant. Hence, count those as failures and not errors
      if ! check-payload scan local \
          --path="/tekton/home/unpacked-${image_num}-${component_label}-${version_label}-${release_label}" \
          "${check_payload_version}" \
          --components="${component_label}" \
          --output-format=csv \
          --output-file="/tekton/home/report-${image_num}-${component_label}-${version_label}-${release_label}.csv"; then
        echo -e "check-payload scan failed for ${related_image}\n"
        # Clean up OCI image and unpacked directory on scan failure to prevent resource accumulation
        cleanup_image_artifacts "${image_num}" "${component_label}" "${version_label}" "${release_label}"
        echo "1" >> "${counter_dir}/failure"
        return
      fi

      if [ -f "/tekton/home/report-${image_num}-${component_label}-${version_label}-${release_label}.csv" ]; then
        if grep -q -- "---- Successful run" "/tekton/home/report-${image_num}-${component_label}-${version_label}-${release_label}.csv"; then
          echo -e "check-payload scan was successful for ${related_image}\n"
          echo "1" >> "${counter_dir}/success"
          # Clean up OCI image and unpacked directory on successful run to save space
          cleanup_image_artifacts "${image_num}" "${component_label}" "${version_label}" "${release_label}"
        elif grep -q -- "---- Successful run with warnings" "/tekton/home/report-${image_num}-${component_label}-${version_label}-${release_label}.csv"; then
          echo -e "check-payload scan was successful with warnings for ${related_image}\n"
          echo "1" >> "${counter_dir}/warnings"
          # Clean up OCI image and unpacked directory on successful run with warnings to save space
          cleanup_image_artifacts "${image_num}" "${component_label}" "${version_label}" "${release_label}"
        fi
      fi
    }

    if [ ! -e "/tekton/home/unique_related_images.txt" ]; then
      echo "No relatedImages to process"
      exit 0
    fi

    mapfile -d ' ' -t related_images < <(cat /tekton/home/unique_related_images.txt)
    echo "Related images are :"
    printf "%s\n" "${related_images[@]}"

    # If target OCP version is found, use it to apply the exception list when running check-payload
    check_payload_version=""
    if [ -f "/tekton/home/target_ocp_version.txt" ]; then
      version=$(cat "/tekton/home/target_ocp_version.txt")
      check_payload_version="-V=${version}"
      echo "Target OCP version found: ${check_payload_version}"
    fi

    # Check if an image to mirror map is defined for unreleased images
    image_mirror_map=""
    if [ -f "/tekton/home/related-images-map.txt" ]; then
      image_mirror_map=$(cat "/tekton/home/related-images-map.txt")
      echo "Image Mirror Map found:"
      echo "${image_mirror_map}" | jq '.'
    fi

    # Process images in parallel with MAX_PARALLEL limit
    echo "Processing ${#related_images[@]} images with MAX_PARALLEL=${MAX_PARALLEL}"
    declare -i count=0
    for related_image in "${related_images[@]}"; do
      count+=1
      # Wait if we've reached the parallel limit
      while [ "$(jobs -r | wc -l)" -ge "${MAX_PARALLEL}" ]; do
        wait -n
      done
      # Launch background job to process image
      process_image "$related_image" "$count" "${#related_images[@]}" "$check_payload_version" "$image_mirror_map" &
    done

    # Wait for all background jobs to complete
    wait

    # Aggregate results from counter files
    success_counter=0
    warnings_counter=0
    error_counter=0
    failure_counter=0

    if [ -f "${counter_dir}/success" ]; then
      success_counter=$(wc -l < "${counter_dir}/success")
    fi
    if [ -f "${counter_dir}/warnings" ]; then
      warnings_counter=$(wc -l < "${counter_dir}/warnings")
    fi
    if [ -f "${counter_dir}/error" ]; then
      error_counter=$(wc -l < "${counter_dir}/error")
    fi
    if [ -f "${counter_dir}/failure" ]; then
      failure_counter=$(wc -l < "${counter_dir}/failure")
    fi

    echo "Results: success=${success_counter}, warnings=${warnings_counter}, errors=${error_counter}, failures=${failure_counter}"

    note="Task $(context.task.name) failed: Some images could not be scanned. For details, check Tekton task log."
    ERROR_OUTPUT=$(make_result_json -r ERROR -t "$note")

    note="Task $(context.task.name) completed: Check result for task result."
    if [[ "$error_counter" == 0 ]];
    then
      if [[ "${failure_counter}" -gt 0 ]]; then
        RES="FAILURE"
      elif [[ "${warnings_counter}" -gt 0 ]]; then
        RES="WARNING"
      else
        RES="SUCCESS"
      fi
      TEST_OUTPUT=$(make_result_json \
        -r "${RES}" \
        -s "${success_counter}" -f "${failure_counter}" -w "${warnings_counter}" -t "$note")
    fi
    echo "${TEST_OUTPUT:-${ERROR_OUTPUT}}" | tee "$(step.results.TEST_OUTPUT.path)"

---
apiVersion: tekton.dev/v1
kind: Task
metadata:
  name: verify-source
  annotations:
    tekton.dev/pipelines.minVersion: 0.21.0
    tekton.dev/tags: security, slsa
  labels:
    app.kubernetes.io/version: "0.1"
spec:
  description: |
    The verify-source Task verifies the SLSA source level of a git commit
    by checking for a Verification Summary Attestation (VSA) stored as a
    git note. The task fetches git notes from the repository and parses
    the VSA to extract the verified SLSA source level.

    WARNING: This task relies on VSAs generated by source-tool
    (https://github.com/slsa-framework/source-tool) which is currently a
    proof-of-concept and under active development. It should not be used in
    production environments. It supports GitHub and GitLab repositories,
    and may encounter API rate limits without authentication.
  params:
    - name: url
      description: Repository URL to verify.
      type: string
    - name: revision
      description: Commit SHA to verify.
      type: string
  results:
    - name: SLSA_SOURCE_LEVEL_ACHIEVED
      description: The SLSA source level achieved by this commit
    - name: TEST_OUTPUT
      description: JSON formatted test results for SLSA verification
  workspaces:
    - name: basic-auth
      description: |
        A Workspace containing a token file for API authentication.
        The workspace should contain a file named 'token' with a GitHub
        personal access token, GitLab personal access token, or other
        authentication token. The task will automatically set the appropriate
        environment variable (GITHUB_TOKEN or GITLAB_TOKEN) based on the
        repository host. This is used to avoid rate limiting when accessing
        the API. Binding a Secret to this Workspace is strongly recommended
        over other volume types.
      optional: true
  steps:
    - name: slsa-verify
      image: quay.io/konflux-ci/git-clone@sha256:bd303d16e9d9b01622d69deff77c583ebdea36611b15dc243da658d93763e8de
      env:
        - name: PARAM_URL
          value: $(params.url)
        - name: PARAM_REVISION
          value: $(params.revision)
        - name: WORKSPACE_BASIC_AUTH_DIRECTORY_BOUND
          value: $(workspaces.basic-auth.bound)
        - name: WORKSPACE_BASIC_AUTH_DIRECTORY_PATH
          value: $(workspaces.basic-auth.path)
      script: |
        #!/usr/bin/env bash
        set -euo pipefail

        # Initialize variables
        REPO_URL="${PARAM_URL}"
        COMMIT_SHA="${PARAM_REVISION}"

        # Extract repository information
        REPO_HOST=$(echo "$REPO_URL" | awk -F/ '{print $3}')
        REPO_OWNER=$(echo "$REPO_URL" | awk -F/ '{print $4}')
        REPO_NAME=$(echo "$REPO_URL" | awk -F/ '{print $5}' | sed 's/\.git$//')

        # Check for token in workspace and set appropriate environment variable
        if [ "${WORKSPACE_BASIC_AUTH_DIRECTORY_BOUND}" = "true" ]; then
          if [ -f "${WORKSPACE_BASIC_AUTH_DIRECTORY_PATH}/token" ]; then
            TOKEN=$(cat "${WORKSPACE_BASIC_AUTH_DIRECTORY_PATH}/token")

            # Set appropriate environment variable based on repo host
            case "$REPO_HOST" in
              *github.com)
                export GITHUB_TOKEN="$TOKEN"
                echo "Using GitHub token from workspace for authentication"
                ;;
              *gitlab.com|*gitlab.*)
                export GITLAB_TOKEN="$TOKEN"
                echo "Using GitLab token from workspace for authentication"
                ;;
              *)
                echo "Warning: Unknown host $REPO_HOST, token authentication may not work"
                ;;
            esac
          fi
        fi

        echo "=== SLSA Source Verification ==="
        echo "Repository: $REPO_HOST/$REPO_OWNER/$REPO_NAME"
        echo "Commit: $COMMIT_SHA"

        # Initialize test results
        VERIFICATION_RESULT="PASSED"
        ACHIEVED_LEVEL="SLSA_SOURCE_LEVEL_1"
        SUCCESSES=0
        FAILURES=0
        WARNINGS=0
        TESTS=()

        # Attempt to verify with source-tool and fetch VSA
        echo "Running SLSA source verification..."

        # Create a temporary directory for git operations
        TEMP_DIR=$(mktemp -d)
        cd "$TEMP_DIR"

        # Initialize a bare repository and fetch only the notes
        git init --bare repo.git
        cd repo.git

        # Fetch the git notes containing VSAs
        # Note: We only fetch notes, not the entire repository
        if git fetch "$REPO_URL" 'refs/notes/commits:refs/notes/commits' 2>&1; then
          echo "Successfully fetched git notes from repository"

          # Try to get the VSA for this commit
          VSA_NOTE=$(git notes --ref=commits show "$COMMIT_SHA" 2>/dev/null || echo "")

          if [ -z "$VSA_NOTE" ]; then
            echo "No VSA found in git notes for this commit"
            WARNINGS=$((WARNINGS + 1))
            TESTS+=('{"name":"vsa-fetch","result":"WARNING"}')
            # Fallback to basic level 1
            ACHIEVED_LEVEL="SLSA_SOURCE_LEVEL_1"
          else
            echo "VSA found in git notes"
            SUCCESSES=$((SUCCESSES + 1))
            TESTS+=('{"name":"vsa-fetch","result":"PASSED"}')

            # Parse the VSA to extract the SLSA level
            # VSA note contains two JSON objects - the second one has the actual VSA
            # Extract the second JSON object and decode its payload using bash tools
            VSA_JSON=$(echo "$VSA_NOTE" | tail -1)

            # Extract the base64 payload from dsseEnvelope.payload field
            PAYLOAD_B64=$(echo "$VSA_JSON" | grep -o '"payload":"[^"]*"' | sed 's/"payload":"//;s/"$//')

            if [ -n "$PAYLOAD_B64" ]; then
              # Decode the payload
              DECODED_PAYLOAD=$(echo "$PAYLOAD_B64" | base64 -d 2>/dev/null || echo "")

              if [ -n "$DECODED_PAYLOAD" ]; then
                # Extract verifiedLevels array - look for "verifiedLevels":["SLSA_SOURCE_LEVEL_X"]
                EXTRACTED_LEVEL=$(echo "$DECODED_PAYLOAD" | \
                  grep -o '"verifiedLevels":\["[^"]*"' | \
                  sed 's/"verifiedLevels":\["\([^"]*\)"/\1/')

                if [ -n "$EXTRACTED_LEVEL" ]; then
                  ACHIEVED_LEVEL="$EXTRACTED_LEVEL"
                  echo "Extracted SLSA level from VSA: $ACHIEVED_LEVEL"
                else
                  # Fallback if we can't parse the level
                  ACHIEVED_LEVEL="SLSA_SOURCE_LEVEL_1"
                  echo "Could not parse SLSA level from VSA, defaulting to: $ACHIEVED_LEVEL"
                fi
              else
                ACHIEVED_LEVEL="SLSA_SOURCE_LEVEL_1"
                echo "Could not decode VSA payload, defaulting to: $ACHIEVED_LEVEL"
              fi
            else
              ACHIEVED_LEVEL="SLSA_SOURCE_LEVEL_1"
              echo "Could not extract payload from VSA, defaulting to: $ACHIEVED_LEVEL"
            fi
          fi
        else
          echo "Failed to fetch git notes from repository"
          WARNINGS=$((WARNINGS + 1))
          TESTS+=('{"name":"vsa-fetch","result":"WARNING"}')
          # Fallback to basic level 1
          ACHIEVED_LEVEL="SLSA_SOURCE_LEVEL_1"
        fi

        # Clean up temp directory
        cd /
        rm -rf "$TEMP_DIR"

        SUCCESSES=$((SUCCESSES + 1))
        TESTS+=('{"name":"slsa-level-determination","result":"PASSED"}')

        # Generate test output JSON
        TESTS_JSON=$(printf '%s\n' "${TESTS[@]}" | paste -sd ',' -)

        TEST_OUTPUT=$(
          cat <<EOF
        {
          "result": "$VERIFICATION_RESULT",
          "timestamp": "$(date -u +%Y-%m-%dT%H:%M:%SZ)",
          "namespace": "slsa-source-verification",
          "successes": $SUCCESSES,
          "failures": $FAILURES,
          "warnings": $WARNINGS,
          "tests": [$TESTS_JSON]
        }
        EOF
        )

        # Write results
        echo "$ACHIEVED_LEVEL" >"$(results.SLSA_SOURCE_LEVEL_ACHIEVED.path)"
        echo "$TEST_OUTPUT" >"$(results.TEST_OUTPUT.path)"

        echo "=== SLSA Verification Summary ==="
        echo "Result: $VERIFICATION_RESULT"
        echo "Achieved Level: $ACHIEVED_LEVEL"
        echo "Successes: $SUCCESSES, Failures: $FAILURES, Warnings: $WARNINGS"
      securityContext:
        runAsUser: 0

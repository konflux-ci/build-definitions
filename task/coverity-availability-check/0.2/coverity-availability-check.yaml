apiVersion: tekton.dev/v1
kind: Task
metadata:
  labels:
    app.kubernetes.io/version: "0.1"
  annotations:
    tekton.dev/pipelines.minVersion: "0.12.1"
    tekton.dev/tags: "konflux"
  name: coverity-availability-check
spec:
  description: >-
    This task performs needed checks in order to use Coverity image in the pipeline. It will check for a Coverity license secret and an authentication secret for pulling the image.
  results:
    - description: Tekton task result output.
      name: TEST_OUTPUT
    - description: Tekton task simple status to be later checked
      name: STATUS
  params:
    - name: COV_LICENSE
      description: Name of secret which contains the Coverity license. Only required for public Konflux instances.
      default: cov-license
    - name: AUTH_TOKEN_COVERITY_IMAGE
      description: Name of secret which contains the authentication token for pulling the Coverity image.
      default: "auth-token-coverity-image"
  volumes:
    - name: cov-license
      secret:
        secretName: $(params.COV_LICENSE)
        optional: true
    - name: auth-token-coverity-image
      secret:
        secretName: $(params.AUTH_TOKEN_COVERITY_IMAGE)
        optional: true
    - name: trusted-ca
      configMap:
        name: trusted-ca
        items:
        - key: ca-bundle.crt
          path: ca-bundle.crt
        optional: true
  steps:
    - name: coverity-availability-check
      image: quay.io/konflux-ci/konflux-test:v1.4.20@sha256:f9db697d8a45870b862252de61b3c29d9d6f79272ef8bf61ecb645f8bca27705
      # per https://kubernetes.io/docs/concepts/containers/images/#imagepullpolicy-defaulting
      # the cluster will set imagePullPolicy to IfNotPresent
      volumeMounts:
        - name: cov-license
          mountPath: "/etc/secrets/cov"
          readOnly: true
        - name: auth-token-coverity-image
          mountPath: "/etc/secrets/auth/config.json"
          subPath: .dockerconfigjson
        - name: trusted-ca
          mountPath: /mnt/trusted-ca
          readOnly: true
      env:
        - name: COV_LICENSE
          value: $(params.COV_LICENSE)
        - name: AUTH_TOKEN_COVERITY_IMAGE
          value: $(params.AUTH_TOKEN_COVERITY_IMAGE)
      script: |
        #!/usr/bin/env bash
        set -eo pipefail
        # shellcheck source=/dev/null
        . /utils.sh
        trap 'handle_error $(results.TEST_OUTPUT.path)' EXIT

        # Checking Coverity license
        COV_LICENSE_PATH=/etc/secrets/cov/cov-license
        if [ -f "${COV_LICENSE_PATH}" ] && [ -s "${COV_LICENSE_PATH}" ]; then
          echo "Coverity license detected!"
        else
          # try to retrieve from internal URL, requires trusting internal CA
          CA_BUNDLE=/mnt/trusted-ca/ca-bundle.crt
          TMP_LICENSE_PATH="/tmp/coverity-license.dat"
          if [ -f "${CA_BUNDLE}" ]; then
            echo "INFO: Using mounted CA bundle: ${CA_BUNDLE}"
            cp -vf ${CA_BUNDLE} /etc/pki/ca-trust/source/anchors
            update-ca-trust

            LICENSE_URL="https://cov01.lab.eng.brq2.redhat.com/coverity/license/license.dat"
            echo -n "Trying to retrieve license at ${LICENSE_URL} ... "
            curl -L --fail --max-time 30 --no-progress-meter "${LICENSE_URL}" -o "${TMP_LICENSE_PATH}" || rm -f "${TMP_LICENSE_PATH}"
          fi

          if [ -f "${TMP_LICENSE_PATH}" ] && [ -s "${TMP_LICENSE_PATH}" ]; then
            echo "Coverity license retrieved from internal URL!"
          else
            echo 'No license file for Coverity was detected. Coverity scan will not be executed...'
            echo 'Please, create a Secret called 'cov-license' with a key called 'cov-license' and the value containing the Coverity license'
            note="Task $(context.task.name) failed: No license file for Coverity was detected. Please, create a secret called 'cov-license' with a key called 'cov-license' and the value containing the Coverity license"
            TEST_OUTPUT=$(make_result_json -r FAILURE -t "$note" -f 1)
            echo -n "failed" | tee "$(results.STATUS.path)"
            echo "${TEST_OUTPUT}" | tee "$(results.TEST_OUTPUT.path)"
            exit 0
          fi
        fi

        # Checking authentication token for downloading coverity image
        AUTH_TOKEN_COVERITY_IMAGE_PATH=/etc/secrets/auth/config.json
        if [ -f "${AUTH_TOKEN_COVERITY_IMAGE_PATH}" ] && [ -s "${AUTH_TOKEN_COVERITY_IMAGE_PATH}" ]; then
          echo "Authentication token detected!"
        else
          echo 'No authentication token for downloading Coverity image detected. Coverity scan will not be executed...'
          echo 'Please, create an imagePullSecret named 'auth-token-coverity-image' with the authentication token for pulling the Coverity image'
          note="Task $(context.task.name) failed: No authentication token for downloading Coverity image detected. Please, create an imagePullSecret named 'auth-token-coverity-image' with the authentication token for pulling the Coverity image"
          TEST_OUTPUT=$(make_result_json -r FAILURE -t "$note" -f 1)
          echo -n "failed" | tee "$(results.STATUS.path)"
          echo "${TEST_OUTPUT}" | tee "$(results.TEST_OUTPUT.path)"
          exit 0
        fi

        note="Task $(context.task.name) completed: Coverity availability checks finished succesfully."
        # shellcheck disable=SC2034
        TEST_OUTPUT=$(make_result_json -r SUCCESS -s 1 -t "$note")
        echo -n "success" | tee "$(results.STATUS.path)"
        echo "${TEST_OUTPUT}" | tee "$(results.TEST_OUTPUT.path)"
